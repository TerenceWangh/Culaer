---
title: 处理器架构
date: 2018/12/12 21:34:18
tags: 
  - 汇编语言
  - 处理器架构
  - 寄存器
category: 汇编相关
description: 该文章主要介绍x86处理器硬件相关概念。中央处理单元处理算术和逻辑运算。它包含了有限数量的存储位置，即寄存器，一个高频时钟用于同步其操作，一个控制单元和一个算术逻辑单元。内存存储单元在计算机程序运行时，保存指令和数据。总线是一组并行线路，在计算机不同部件间传输数据。
---

## 操作模式
x86处理器有三个主要操作模式：保护模式、实地址模式和系统管理模式以及一个子模式：虚拟8086模式作为保护模式的特殊情况。下面给出详细的介绍：
* **保护模式**： 是处理器的原生状态，在这种模式下，所有指令和特性都是可用的。分配给程序的独立内存区域被称为*段*，而处理器会组织程序使用自身段范围之外的内存。
* **虚拟8086模式**： 保护模式下，处理器可以在一个安全环境中直接执行实地址模式软件。换句话说，如果一个程序奔溃了或者是试图向内存区域写数据，都不会影响到同一时间内执行的其他程序。现代操作系统可以同时执行多个独立的虚拟8086会话。
* **实地址模式**： 实现的是早期Intel处理器的编程环境，但是增加了一些其他的特性，如切换到其他模式的功能。当程序需要直接访问系统内存和硬件设备时，这种模式很有用。
* **系统管理模式**： 系统管理模式向操作系统提供了实现诸如电源管理和系统安全等功能的机制。这些功能通常是由计算机制造商实现的，他们为一个特定的系统设置而定制处理器。

## 基本执行环境

### 地址空间
在32位保护模式下，一个任务或程序最大可以寻址4GB的线性地址空间。从P6处理器开始，一种被称为*扩展物理寻址*的技术使得可以被寻址的物理内存空间增加到64GB。与之相反，实地址模式程序只能寻址1MB空间。如果处理器在保护模式下运行多个虚拟8086程序，则每个程序只能拥有自己的1MB内存空间。

### 基本程序执行寄存器
1. **通用寄存器**：主要用于算术运算和数据传输。一些寄存器的低16位可以单独使用，甚至有些寄存器的可以作为8位寄存器使用，下面给出寄存器的表：
    | 32位 | 16位 | 8位(高) | 8位(低) |
    |:---:|:----:|:----:|:----:|
    | EAX |  AX  |  AH  |  AL  |
    | EBX |  BX  |  BH  |  BL  |
    | ECX |  CX  |  CH  |  CL  |
    | EDX |  DX  |  DH  |  DL  |
    | ESI |  SI  |   -  |   -  |
    | EBP |  BP  |   -  |   -  |
    | EDI |  DI  |   -  |   -  |
    | ESP |  SP  |   -  |   -  |
    *特殊使用*：
    * 乘法指令默认使用**EAX**，常常被称为*扩展累加器寄存器*。
    * CPU默认使用ECX位循环计数器。
    * ESP用于寻址堆栈数据，极少用于一般算术运算和数据传输，通常被称为*扩展堆栈指针寄存器*。
    * ESI和EDI用于高速存储器传输指令，有时也被成为*扩展源变址寄存器*和*目的变址寄存器*。
    * 高级语言通过EBP来引用堆栈中的函数和局部变量。之外，它不用于一般算术运算和数据传输。常常也被称为*扩展帧指针寄存器*。

2. **段寄存器**：
    * 实地值模式中，16位段寄存器表示的是预先分配的内存区域的基址，这个内存区域称为*段*。
    * 保护模式中，段寄存器中存放的是段描述符表指针。
    一些段中存放程序指令(代码)，其他段存放变量(数据)，还有一个*堆栈段*存放的是局部函数变量和函数参数。
3. **指令指针**：指令指针(EIP)寄存器中包含下一条将要执行指令的地址。某些机器指令能控制EIP，使得程序分支转向到一个新位置。
4. **EFLAGS寄存器**：EFLAGS寄存器包含了独立的二进制位，用于控制CPU的操作，或是反映一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标志位。
    * 控制标志位：控制CPU的操作。例如，能够使得CPU每执行一条指令后进入中断；在侦测到算术运算溢出时中断执行；进入虚拟8096模式，以及进入保护模式。
    * 状态标志位：状态标志位反映了CPU执行算术和逻辑操作的结果。其中包括：溢出位、符号位、零标志位、辅助进位标志位、奇偶校验位和进位标志位。
      * 进位标志位(CF)：与目标位置相比，无符号算术运算结果太大时，设置该标志位。
      * 溢出标志位(OF)：与目标位置相比，有符号算术运行结果太大或太小时，设置该标志位。
      * 符号标志位(SF)：算术或逻辑操作产生负结果时，设置该标志位。
      * 零标志位(ZF)：算术或逻辑操作产生的结果为0时，设置该标志位。
      * 辅助进位标志位(AC)：算术操作在8位操作数中产生了位3向位4的进位时，设置该标志位。
      * 奇偶校验标志位(PF)：结果的最低有效字节包含偶数个1时，设置该标志位，否则清除该标志位。

### MMX寄存器
为了实现高级多媒体和通信应用时，MMX技术提高了Intel处理器性能。8个64位MMX寄存器支持成为SIMD的特殊指令。顾名思义，MMX指令对MMX寄存器中的数据值进行并行操作。

### XMM寄存器
x86结构还包括8个128位XMM寄存器，被用于SIMD流扩展指令集。
**浮点单元**执行高速浮点算术运算。之前为了这个目的，需要在一个独立的协处理器芯片。从Intel486处理器开始，FPU已经集成到了主处理器芯片上。FPU中有8个浮点数据寄存器，分别命名为ST(0),ST(1),ST(2),ST(3),ST(4),ST(5),ST(6),ST(7)。此外还有FPU指令指针，FPU数据指针，标志寄存器，控制寄存器，状态寄存器等。

## 64位x86-64处理器
基本特征：
1. 向后兼容x86指令集
2. 地址长度为64位，虚拟地址空间位$2^{64}$字节。按照当前芯片的实现情况，目前只能使用地址的低48位。
3. 可以使用64位通用寄存器，允许指令具有64位整数操作数。
4. 比x86多了8个通用寄存器。
5. 物理地址为48位，支持高达256TB的RAM。

### 操作模式
Intel64架构引入了一个新的模式，称为IA-32e。从技术上看，这个模式包含两个子模式：**兼容模式**和**64位模式**。
1. **兼容模式**：在此模式下，现有的16位与32位应用程序通常不用进行重新编译就可以运行。但是，16位Windows和DOS应用程序不能运行在64位Microsoft Windows下。与早期的Windows版本不同，64位Windows没有虚拟DOS机器子系统来利用处理器的功能切换到虚拟8086模式。
2. **64位模式**：在此模式下，处理器执行的是使用64位线性地址空间的应用程序。

### 基本执行环境

64位模式下，虽然处理器现在只能支持48位地址，但是理论上，地址最大为64位。从寄存器来看，64位模式与32位模式主要区别如下：
* 16个64位通用寄存器，32位模式只有8个通用寄存器
* 8个80位浮点寄存器
* 1个64位状态标志寄存器RFLAGS(只能使用低32位)
* 1个64位指令指针寄存器RIP

**通用寄存器**
64位模式下，操作数的默认大小是32位，并且有8个通用寄存器。但是，给每条指令加上REX(寄存器扩展)前缀后，操作数可以达到64位，可用的通用寄存器的数量也增加到16个：32位模式下的寄存器、8个有标号的寄存器、R8到R15。下面给出REX前缀下可用的寄存器：
  | 操作数大小 | 可用寄存器 |
  |:--------:|:---------:|
  |  8位 |  AL,  BL,  CL,  DL,  DIL, SIL, BPL, SPL, R8L, R9L, R10L, R11L, R12L, R13L, R14L, R15L |
  | 16位 |  AX,  BX,  CX,  DX,  DI,  SI,  BP,  SP,  R8W, R9W, R10W, R11W, R12W, R13W, R14W, R15W |
  | 32位 | EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP,  R8D, R9D, R10D, R11D, R12D, R13D, R14D, R15D |
  | 64位 | RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP,  R8,  R9,  R10,  R11,  R12,  R13,  R14,  R15  |
  请记住下面一些细节：
  * 64位模式下，单条指令不能同时访问寄存器的高字节，如AH、BH、CH和DH，以及新字节寄存器的低字节，如DIL。
  * 64位模式下，32位EFLAGS寄存器由64位RFLAGS寄存器取代。这两个寄存器共享低32位，而RFLAGS的高32位是不使用的。
  * 32位模式和64位模式具有相同的状态标志。