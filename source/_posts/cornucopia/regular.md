---
title: 正则表达式
date: 2018/11/29 8:32:20
tags:
  - program
  - regular
category: 杂项
description: 正则表达式相关概念，基本的形式化语言理论以及基本语法操作。
---

## 基本概念
正则表达式，是用来表示特定字符串集的一种表达式。一个定义字符串集的简单方式是列出其所有的元素，但是正则表达式能够更简洁的表示。例如，一个字符串集包括"Handel","Händel"以及"haendel"只需要简单的使用`H(ä|ae?)ndel`来表示，并称为该模型能够匹配三个字符串中的任何一个。
下面给出正则表达式常用的匹配操作：
* **逻辑或**：使用竖直的线表示，例如：`gray|grey`能够匹配"gray"或"grey"。
* **分组(grouping)**：使用括号表示，例如：`gray|grey`和`gr(a|e)y`都能表示"gray"和"grey"的集合，这两个表达式是相同的。
* **定量(Quantification)**：表示符号或者分组出现的次数。通常有以下集中方式：
  符号    | 含义 | 例子
  ------ | ------ | ------
  `?` | 前一元素出现0或1次 | `colou?r`能够匹配"color"以及"colour"
  `*` | 前一元素出现0或多次 | `ab*c`能够匹配"ac","abc","abbc","abbbc"等
  `+` | 前一元素出现1或多次 | `ab+c`能够匹配"abc", "abbc", "abbbc"等，但不能匹配"ac"
  `{n}` | 前一元素恰好出现n次
  `{min, }` | 前一元素最少出现*min*次
* **通配符(Wildcard)**：`.`能够匹配任意的一个字符。例如，`a.b`能够匹配任何以a开始，然后是其他任意*一个*字符，最后以b结尾的字符串。`a.*b`能够匹配任何以a开头并以b结尾的字符串。
>上面的操作能够进行类似于加减乘除的操作，例如`H(ae?|ä)ndel`和`H(a|ae|ä)ndel`都能够跟`H(ä|ae?)ndel`表达式匹配的字符串相同。

## 形式化语言理论
正则表达式包括**常量**(用来表示字符串集)和**算子**(用来表示字符串集之间的操作)。下面给出的定义是标准的，在很多的形式语言上都适用。
给定有限的字母表$\Sigma$，下面的常量被定义为正则表达式：
* 空集：$\phi$
* 空串：$\varepsilon$，表示不含任何字符的字符串。
* 字符：在$\Sigma$的`a`表示集合仅仅包含字符*a*。

给定常规的表达式`R`和`S`，下面定义了产生新的表达式的操作：
* 串接(concatenation) `RS`表示集合包括`R`中字符串和`S`中字符串的连接。例如， R={"ab", "c"}, S={"d", "ef"}，那么RS={"abd", "abef", "cd", "cef"}。
* 选择(alternation) `R|S`表示`R`和`S`的并集。例如，R={"ab", "c"}, S={"ab", "d", "ef"}，那么R|S={"ab", "c", "d", "ef"}。
* Kleene星号 `R*`表示集合中包含$\varepsilon$的最小子集，在字符串的连接下是闭合的。例如， {"0", "1"}\*表示任意的二进制字符串。{"ab", "c"}\*={$\varepsilon$, "ab", "c", "abab", "abc", "cab", "cc", "ababab", "abcab", ...}。

在没有括号的条件下，Kleene星号有最高的优先级，其次是连接，再次是或操作。如果没有歧义，那么括号是可以省略的。如`(ab)c`可以写作`abc`，`a|(b(c*))`可以写作`a|bc*`。

## 基本语法
一个正则表达式通常被称为一个**模式(pattern)**，用来描述或者匹配一系列符合某个句法规则的字符串。大部分正则表达式的形式都有如下结构：

### 选择
* `|`代表选择，具有最低优先级。

### 数量限定
某个字符后的数量限定符用来限定前面这个字符允许出现的个数。最常见的数量限定符包括`+`、`?`和`*`：
* `+`：代表前面的字符必须至少出现一次(即一次或多次)。例如，`goo+gle`可以匹配google、gooogle、goooogle等。
* `?`：代表前面的字符最多可以出现一次(即零次或一次)。例如，`goo?gle`可以匹配gogle、google。
* `*`：代表前面的字符可以出现任意多次，也可以不出现。例如，`goo*gle`可以匹配gogle、google、gooogle等。

### 圆括号
* `()`可以用来定义操作符的范围和优先度。

### PCRE表达式全集
* `\` 将下一个字符标记为一个特殊字符，或一个原义字符(`^$()*+?.[\{|`共12个)，或一个向后引用，或一个八进制转义符。例如，`n`匹配字符`n`，而`\n`匹配的时换行符。
* `^` 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，也匹配`\n`或`\r`之后的位置。
* `$` 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，也匹配`\n`或`\r`之前的位置。
* `*` 匹配前面的子表达式零次或多次，等价于`{0,}`。
* `+` 匹配前面的子表达式一次或多次，等价于`{1,}`。
* `?` 匹配前面的子表达式零次或多次，等价于`{0,1}`。
* `{n}` n是一个非负整数，匹配确定的n次。例如，`o{2}`不能匹配`Bob`中的`o`，但能够匹配`food`中的`o`。
* `{n,}` n是一个非负整数，至少匹配n次。例如，`o{2,}`不能匹配`Bob`中的`o`，但能够匹配`foooood`中所有的`o`。
* `{n, m}` n和m均是一个非负整数，其中`n <= m`。最少匹配n次，最多匹配m次。例如`o{1,3}`将匹配`foooood`中前面的三个`o`。请注意不要加入空格。
* `?` 非贪心量化：当该字符紧跟在任何一个其他重复修饰符(`*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}`)后面时，匹配模式是**非贪婪**的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于`oooo`，`o+?`将匹配单个`o`，但`o+`匹配所有的`o`。
* `.` 匹配除了`\r`、`\n`之外的任何单个字符。要匹配包括`\r`、`\n`的任意字符，可使用`(.|\r|\n)`进行匹配。
* `(pattern)` 匹配pattern并获取这一匹配的子字符串。该子字符串向后引用。
* `(?:pattern)` 匹配pattern但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符`|`来组合一个模式的各部分是非常有用的。例如，`industr(?:y|ies)`就是一个比`industry|industries`简洁的表达式。
* `(?=pattern)` 正向肯定预查，在任何匹配pattern的字符串开始处查找字符串，这是一个非获取匹配。例如，`Windows(?=95|98|NT|2000)`能匹配`Windows2000`中的`Windows`，但不能匹配`Windows3.1`中的`Windows`。预查不消耗字符，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
* `(?!pattern)` 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。是一个非获取匹配。例如，`Windows(?!95|98|NT|2000)`能匹配`Windows3.1`中的`Windows`，但不能匹配`Windows98`中的`Windows`。同样，预查不消耗字符。
* `(?<=pattern)` 反向肯定预查，与正向肯定预查类似，只是方向不同。例如，`(?<=95|98|NT|2000)Windows`能匹配`2000Windows`中的`Windows`，但不能匹配`3.1Windows`中的`Windows`。
* `(?<!pattern)` 反向否定预查，与正向否定预查类似，只是方向不同。例如，`(?<!95|98|NT|2000)Windows`能匹配`3.1Windows`中的`Windows`，但不能匹配`2000Windows`中的`Windows`。
* `x|y` 没有包含在`()`中，其范围是整个正则表达式。例如，`z|food`能匹配`z`或`food`。`(?:z|f)ood`则匹配`zood`或`food`。
* `[xyz]` 字符集和，匹配所包含的任意一个字符。例如，`abc`可以匹配`plain`中的`a`。特殊字符仅有反斜线保持特殊含义，用于转义字符。其他特殊字符如`*`,`+`,各种括号等均作为普通字符。`^`如果出现在首位则表示负值字符集和，如果出现在字符中间就仅作为普通字符。`-`如果出现在字符串中间表示范围描述，如果出现在首位或者末尾则仅作为普通字符。右方括号应使用转义出现，也可以作为首字符出现。
* `[^xyz]` 排除型字符串集和。匹配未列出的任意字符。例如，`[^abc]`可以匹配`plain`中的`plin`。
* `[a-z]` 字符范围，匹配制定范围内的任意字符。`[a-z]`可以匹配`a`到`z`范围内的任意小写字符字母。
* `[^a-z]` 排除型字符范围，匹配任何不在指定范围内的任意字符。例如，`[^a-z]`可以匹配任何不是`a`到`z`范围内的字符。
* `\b` 匹配一个单词边界，也就是指单词和空格间的位置。例如，`er\b`可以匹配`never`中的`er`，但不能匹配`verb`中的`er`。
* `\B` 匹配非单词边界。`er\B`能匹配`verb`中的`er`，但不能匹配`never`中的`er`。
* `\cx` 匹配由x只能的控制字符。x的值必须为`A-Z`或`a-z`之一。否则，将c视为一个原义的`c`字符。控制字符的值等于x的值最低5比特。例如，`\cM`匹配一个Control-M或回车符。`\ca`等效于`\u0001`，`\cb`等效于`\u0002`，等等...
* `\d` 匹配一个数字字符，等价于`[0-9]`，注意Unicode正则表达式会匹配全角数字字符。
* `\D` 匹配一个非数字字符，等价于`[^0-9]`。
* `\f` 匹配一个换页符，等价于`\x0c`和`\cL`。
* `\n` 匹配一个换行符，等价于`\x0a`和`\cJ`。
* `\r` 匹配一个回车符，等价于`\x0d`和`\cM`。
* `\s` 匹配任何空白符，包括空格、制表符、换页符等。等价于`[\f\n\r\t\v]`。注意Unicode正则表达式会匹配全角空格符。
* `\S` 匹配任何非空白符，等价于`[^\f\n\r\t\v]`。
* `\t` 匹配一个制表符，等价于`\x09`和`\cI`。 
* `\v` 匹配一个垂直制表符，等价于`x0b`和`\cK`。
* `\w` 匹配包括下划线的任何单词字符，等价于`[A-Za-z0-9_]`，注意Unicode正则表达式会匹配中文字符。
* `\W` 匹配任何非单词字符，等价于`[^A-Za-z0-9_]`。
* `\xnn` 十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。例如，`\x41`匹配`A`，`\x041`等价于`\x04&1`，正则表达式可以使用ASCII编码。

更多请参考[Wiki](https://en.wikipedia.org/wiki/Regular_expression)

### 优先级
| 优先级 | 符号 |
| --- | --- |
| 最高 | `\` |
| 高 | `()`、`(?:)`、`(?=)`、`[]` |
| 中 | `*`、`+`、`?`、`{n}`、`{n,}`、`{n, m}` |
| 低 | `^`、`$`、中介字符 |
| 次最低 | 串接，即相邻字符连接在一起 |
| 最低 | `|` |